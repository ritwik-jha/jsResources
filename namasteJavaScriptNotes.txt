NAMASTE JAVASCRIPT

window object is the global object.
windown <--> this

1. Hoisting
 --> execution context contains variable environment where variables and funcions are stored and code env where code is stored
 --> js program is executed in two phases 
	--> P1: Memory creation phase: Variables and functions are hoisted
	--> P2: Code execution phase: Code is executed
 --> undefined keyword --> placeholder
 --> first all the variables are hoisted with undefined and functions are hoisted with complete function body.
 --> then all the variables are assigned values and functions are executed.
 
2. Scope chain and lexical env
 --> every execution context can access the execution context of its parents
 --> the execution context of parent is called lexical environment.
 
 
3. let vs var vs const
 --> vars and let are hoisted with undefined initially.
 --> let variables cannot be accessed before value assignment. 
 --> the time between hoisting and value initiallization for let variable is called temporal dead zone.
 --> acessing variable in temporal dead zone gives reference error.
 --> let and const are not stored in the global object they are stored in different space
 --> let variables cannot be redeclared.
 --> const cannot be declared and initiallized later it has to be initiallized in same line.
 --> assigning diff value to const variable throws TypeError
 --> preference order:  const > let > var
 --> initiallization of variables should be done at top of code to avaoid temporal dead zone

4. Block scope and shadowing
 --> Block in js => {} 
 --> Block is used to write multiple lines of code where js allows only single line
 --> it is also called compound statement
 --> scope of block -> variables and functions which can be accessed within the block.
 --> hoisting in block 
	--> let and const variables declared inside block have block scope only and cannot be accessed outside the block
	--> var variable inside the block is created in global scope and can be accessed outside the block

5. Shadowing
 --> example
	var a = 100; --> created in global scope
	{
	var a = 10; --> overrides the a created in global scope
	let b = 20; --> created in block scope
	const c = 30; --> creted in blcok scope
	console.log(a); --> 10
	console.log(b); --> 20
	console.log(c); --> 30
	}
	console.log(a); --> 10 --> the a in global scope has been shadowed by a in block
 --> example 2
	let b = 100; --> created in script scope
	{
	var a = 10; --> created in global scope
	let b = 20; --> created in block scope
	const c = 30; --> creted in blcok scope
	console.log(a); --> 10
	console.log(b); --> 20 : the b in block scope shadows the b in script scope so output is 30
	console.log(c); --> 30
	}
	console.log(b); --> 100 --> the b in block scope does not exists after running the block so this outputs 100 from the script scope

--> example 3
	let b = 100;
	function x(){
	let b = 30;
	console.log(b);
	}
	x(); --> 30 : the b in function scope shadows the b in script scope so output is 30
	console.log(b); --> 100 : after execution, function scope does not exists so the value is taken from the script scope

--> let variables cannot be shadowed by var variables in block scope but can be shadowed using fucntion scope
	let a = 100;
	{
	var a = 10;
	} --> not allowed
	

	let a = 100;
	function x(){
	var a = 10;
	} --> allowed

6. Closures
 --> Closure is a function binded with its lexical environment
 --> in js a function can return a function 
	function x(){
	  var a = 7;
	  function y(){
	    console.log(a);
	  }
	  return y;
	}

	var z = x();	
	z() --> prints 7

--> this happens because x return not only the function y but the entire closure 
--> so the functions remember their lexical environment even when the lexical env doesn't exists anymore.

7. setTimeout
 --> setTimeout function takes a callback function and a time
 --> it stores the callback function and waits for the timer to expire
 --> once expired it puts the callback function in call stack and runs it
 --> this doesn't means that the js program stops executing for the given time at setTimeout call and then proceeds.
 --> it proceeds and executes rest of the code

	function x(){
	  var i = 1;
	  setTimeout(function(){
		console.log(i);
	  }, 3000);
	  console.log("hello");
	}
	x();
	--> hello
	after 3s
	--> 1

 --> In closures the function remembers the reference to the variables rather than the value of variable.

	function x(){
	  for(var i = 1; i<=5; i++){
	    setTimeout(function(){
		console.log(i);
	    }, i*1000);
	  }
	}
	x();
	--> 6
	--> 6
	--> 6
	--> 6
	--> 6
 --> this happens because the setTimeout takes the callback function with the closure pointing towards var i in global scope and waits for the timer.
 --> when the setTimeout puts the function in call stack the i variable has become 6 so it prints 6 only.

 --> To solve this have to pass different copies of i to the callback function, so we can use let instead of var

	function x(){
	  for(let i = 1; i<=5; i++){
	    setTimeout(function(){
		console.log(i);
	    }, i*1000);
	  }
	}
	x();

 --> As let has block scope everytime the setTimeout stores the callback function each i poitns to a different variable with different values.

 --> To pass different copies of i to the callback function we can also create another closure inside the loop

	function x(){
	  for(var i = 1; i<=5; i++){
	    function close(h){
		setTimeout(function(){
		console.log(h);
	    }, h*1000);
	    }
	    close(i);
	  }
	}
	x();

 --> the closure function remembers the reference to its parents variables and function even when it is being executed in some other scope.

7. First class functions
 --> Anonimous function is function without any name
 --> Function statement
	function a(){
		console.log();
	}
 --> function expression
	var b = function() {
		console.log();
	}

 --> difference between the two is in terms of hoisting. 
 --> In case of a the entire function is stored in memory allocation phase. In case of b the during memory allocation phase the b is stored is undefined.

 --> function statement <--> function decleration

 --> anonymous function
	function (){
		console.log();
	}

 --> named function expression
	var b = function xyz(){
		console.log();
	}

	b();  //executes the function
	xyz(); // throws error
 --> xyz(); throws error because function xyz is not defined in global scope and cannot be accessed. It can be accessed within the funciton's local scope.

--> prameters vs arguments
	function a(parameter1, parameter2){

	}

	a(argument1, argument2);

--> first class function
    -> functions can take functions as arguments and can return functions
    -> the ability of functions to be used as values and be able to pass it as arguments and return from another function is called first class function

--> first class functions <-> first class citizens

--> Arrow functions

8. Callback Functions
 --> the function passed into another function as argument is called the callback function.
	function x(){}

	x(function y(){});
	-> here y is the callback function.

 --> EventListners
	document.getElementById("").addEventListner("click", function (){});

	the event listner stores the function and puts it in the call stack when it detects the event.



